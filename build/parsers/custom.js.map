{
  "version": 3,
  "sources": ["../../src/parsers/custom.ts"],
  "sourcesContent": ["import { NodeVM } from 'vm2';\nimport type { CanBusAdapter } from '../main';\nimport { ParserBase } from './base';\n\ntype ScriptRead = (buffer: Buffer) => Promise<boolean | number | string | null>;\ntype ScriptWrite = (buffer: Buffer, value: boolean | number | string | null) => Promise<Buffer>;\n\n/**\n * Parser for handling of custom values using user defined scripts.\n * The user defined scripts will always run in a vm2 instance.\n */\nexport class ParserCustom extends ParserBase {\n\n  protected static readonly handledDataTypes: ioBroker.AdapterConfigDataType[] = [\n    'custom',\n  ];\n\n  private static vm: NodeVM | null = null;\n\n  private scriptRead: ScriptRead | null = null;\n  private scriptWrite: ScriptWrite | null = null;\n\n  constructor (adapter: CanBusAdapter, parserConfig: ioBroker.AdapterConfigMessageParser) {\n    super(adapter, parserConfig);\n\n    // setup static VM instance on first call\n    if (ParserCustom.vm === null) {\n      ParserCustom.vm = new NodeVM({\n        sandbox: {\n          getStateAsync: this.adapter.getForeignStateAsync,\n          getObjectAsync: this.adapter.getForeignObjectAsync,\n          log: this.adapter.log,\n          sharedData: {}, // object to share some data between custom parsers\n        },\n      });\n    }\n\n    // prepare read script\n    if (this.cfg.customScriptRead) {\n      try {\n        this.scriptRead = ParserCustom.vm.run(`\n          module.exports = async (buffer) => {\n            let value = undefined;\n            ${this.cfg.customScriptRead}\n            return value;\n          }\n        `) as ScriptRead;\n      } catch (err) {\n        this.adapter.log.warn(`Error loading custom read script for parser ${this.cfg.id}! ${err}`);\n        if (err instanceof Error && typeof err.stack === 'string') {\n          this.adapter.log.warn(err.stack.replace(/^\\s*vm\\.js:\\d+.*$(\\n)/im, '').replace(/^\\s*at new Script[^]*$/im, ''));\n        }\n      }\n    } else {\n      this.adapter.log.warn(`No read script defined for parser ${this.cfg.id}! Data cannot be read.`);\n    }\n\n    // prepare write script\n    if (this.cfg.customScriptWrite) {\n      try {\n        this.scriptWrite = ParserCustom.vm.run(`\n          module.exports = async (buffer, value) => {\n            ${this.cfg.customScriptWrite}\n            return buffer;\n          }\n        `) as ScriptWrite;\n      } catch (err) {\n        this.adapter.log.warn(`Error loading custom write script for parser ${this.cfg.id}! ${err}`);\n        if (err instanceof Error && typeof err.stack === 'string') {\n          this.adapter.log.warn(err.stack.replace(/^\\s*vm\\.js:\\d+.*$(\\n)/im, '').replace(/^\\s*at new Script[^]*$/im, ''));\n        }\n      }\n    } else {\n      this.adapter.log.warn(`No write script defined for parser ${this.cfg.id}! Data cannot be written.`);\n    }\n  }\n\n  public async read (buf: Buffer): Promise<boolean | number | string | null | Error> {\n    if (!this.scriptRead) {\n      return new Error('No read script defined');\n    }\n    try {\n      const value = await this.scriptRead(buf);\n\n      // check if the correct data type is returned and log a warning if not\n      // ... but not if undefined is returned because this may be expected\n      if (value !== undefined && this.cfg.customDataType && this.cfg.customDataType !== 'mixed' && typeof value !== this.cfg.customDataType) {\n        this.adapter.log.warn(`Parser ${this.cfg.id} returned wrong data type ${typeof value}. (expected ${this.cfg.customDataType})`);\n      }\n\n      return value;\n    } catch (err) {\n      return err as Error;\n    }\n  }\n\n  public async write (buf: Buffer, val: boolean | number | string | null): Promise <Buffer | Error> {\n    if (!this.scriptWrite) {\n      return new Error('No write script defined');\n    }\n    try {\n      return await this.scriptWrite(buf, val);\n    } catch (err) {\n      return err as Error;\n    }\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAAuB;AAEvB,kBAA2B;AASpB,MAAM,gBAAN,MAAM,sBAAqB,uBAAW;AAAA,EAW3C,YAAa,SAAwB,cAAmD;AACtF,UAAM,SAAS,YAAY;AAJ7B,SAAQ,aAAgC;AACxC,SAAQ,cAAkC;AAMxC,QAAI,cAAa,OAAO,MAAM;AAC5B,oBAAa,KAAK,IAAI,kBAAO;AAAA,QAC3B,SAAS;AAAA,UACP,eAAe,KAAK,QAAQ;AAAA,UAC5B,gBAAgB,KAAK,QAAQ;AAAA,UAC7B,KAAK,KAAK,QAAQ;AAAA,UAClB,YAAY,CAAC;AAAA;AAAA,QACf;AAAA,MACF,CAAC;AAAA,IACH;AAGA,QAAI,KAAK,IAAI,kBAAkB;AAC7B,UAAI;AACF,aAAK,aAAa,cAAa,GAAG,IAAI;AAAA;AAAA;AAAA,cAGhC,KAAK,IAAI,gBAAgB;AAAA;AAAA;AAAA,SAG9B;AAAA,MACH,SAAS,KAAK;AACZ,aAAK,QAAQ,IAAI,KAAK,+CAA+C,KAAK,IAAI,EAAE,KAAK,GAAG,EAAE;AAC1F,YAAI,eAAe,SAAS,OAAO,IAAI,UAAU,UAAU;AACzD,eAAK,QAAQ,IAAI,KAAK,IAAI,MAAM,QAAQ,2BAA2B,EAAE,EAAE,QAAQ,4BAA4B,EAAE,CAAC;AAAA,QAChH;AAAA,MACF;AAAA,IACF,OAAO;AACL,WAAK,QAAQ,IAAI,KAAK,qCAAqC,KAAK,IAAI,EAAE,wBAAwB;AAAA,IAChG;AAGA,QAAI,KAAK,IAAI,mBAAmB;AAC9B,UAAI;AACF,aAAK,cAAc,cAAa,GAAG,IAAI;AAAA;AAAA,cAEjC,KAAK,IAAI,iBAAiB;AAAA;AAAA;AAAA,SAG/B;AAAA,MACH,SAAS,KAAK;AACZ,aAAK,QAAQ,IAAI,KAAK,gDAAgD,KAAK,IAAI,EAAE,KAAK,GAAG,EAAE;AAC3F,YAAI,eAAe,SAAS,OAAO,IAAI,UAAU,UAAU;AACzD,eAAK,QAAQ,IAAI,KAAK,IAAI,MAAM,QAAQ,2BAA2B,EAAE,EAAE,QAAQ,4BAA4B,EAAE,CAAC;AAAA,QAChH;AAAA,MACF;AAAA,IACF,OAAO;AACL,WAAK,QAAQ,IAAI,KAAK,sCAAsC,KAAK,IAAI,EAAE,2BAA2B;AAAA,IACpG;AAAA,EACF;AAAA,EAEA,MAAa,KAAM,KAAgE;AACjF,QAAI,CAAC,KAAK,YAAY;AACpB,aAAO,IAAI,MAAM,wBAAwB;AAAA,IAC3C;AACA,QAAI;AACF,YAAM,QAAQ,MAAM,KAAK,WAAW,GAAG;AAIvC,UAAI,UAAU,UAAa,KAAK,IAAI,kBAAkB,KAAK,IAAI,mBAAmB,WAAW,OAAO,UAAU,KAAK,IAAI,gBAAgB;AACrI,aAAK,QAAQ,IAAI,KAAK,UAAU,KAAK,IAAI,EAAE,6BAA6B,OAAO,KAAK,eAAe,KAAK,IAAI,cAAc,GAAG;AAAA,MAC/H;AAEA,aAAO;AAAA,IACT,SAAS,KAAK;AACZ,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EAEA,MAAa,MAAO,KAAa,KAAiE;AAChG,QAAI,CAAC,KAAK,aAAa;AACrB,aAAO,IAAI,MAAM,yBAAyB;AAAA,IAC5C;AACA,QAAI;AACF,aAAO,MAAM,KAAK,YAAY,KAAK,GAAG;AAAA,IACxC,SAAS,KAAK;AACZ,aAAO;AAAA,IACT;AAAA,EACF;AACF;AA/Fa,cAEe,mBAAqD;AAAA,EAC7E;AACF;AAJW,cAMI,KAAoB;AAN9B,IAAM,eAAN;",
  "names": []
}
