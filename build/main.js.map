{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["import * as utils from '@iobroker/adapter-core';\nimport { boundMethod } from 'autobind-decorator';\nimport { CanMessage } from 'socketcan';\n\nimport { CanInterface } from './can-interface';\nimport { getHexId, PromiseQueue } from './helpers';\n\nimport { knownParsers } from './parsers';\n\nimport {\n  MESSAGE_ID_REGEXP,\n  MESSAGE_ID_REGEXP_WITH_DLC,\n  PARSER_COMMON_STATES_REGEXP,\n  PARSER_ID_REGEXP,\n  PARSER_ID_RESERVED,\n} from './consts';\n\nexport class CanBusAdapter extends utils.Adapter {\n\n  private canInterface: CanInterface | null = null;\n\n  /**\n   * Mapping of CAN hex message IDs to the message configs.\n   * The IDs must be hex strings (3 or 8 chars) to differentiate between\n   * stanard frame and extended frame messages.\n   */\n  private canId2Message: Record<string, MessageConfig> = {};\n\n  /**\n   * Set of intervals that needs to be cleared on adapter unload.\n   */\n  private intervals: Set<NodeJS.Timeout> = new Set<NodeJS.Timeout>();\n\n  constructor (options: Partial<utils.AdapterOptions> = {}) {\n    super({\n      ...options,\n      name: 'canbus',\n    });\n\n    this.on('ready', this.onReady);\n    this.on('stateChange', this.onStateChange);\n    this.on('unload', this.onUnload);\n  }\n\n  /**\n   * Is called when databases are connected and adapter received configuration.\n   */\n  @boundMethod\n  private async onReady (): Promise<void> {\n    // Reset the connection indicator during startup\n    await this.setState('info.connection', false, true);\n\n    await this.setupObjects();\n\n    this.canInterface = new CanInterface(this);\n    this.canInterface.on('stopped', () => this.setState('info.connection', false, true));\n    this.canInterface.on('message', this.handleCanMsg);\n\n    if (this.canInterface.start()) {\n      this.log.debug('can interface started');\n      await this.setState('info.connection', true, true);\n    }\n\n    await this.subscribeStatesAsync('*');\n  }\n\n  /**\n   * Is called when adapter shuts down - callback has to be called under any circumstances!\n   */\n  @boundMethod\n  private onUnload (callback: () => void): void {\n    try {\n      if (this.canInterface) {\n        this.canInterface.stop();\n      }\n\n      // stop intervals\n      for (const interv of this.intervals) {\n        clearInterval(interv);\n      }\n\n      this.log.debug('cleaned everything up...');\n      callback();\n    } catch (_e) {\n      callback();\n    }\n  }\n\n  /**\n   * Is called if a subscribed state changes.\n   *\n   * This will trigger the sending of messages and conversion from parser states\n   * into message json states if configured.\n   */\n  @boundMethod\n  private async onStateChange (id: string, state: ioBroker.State | null | undefined): Promise<void> {\n    if (state) {\n      // The state was changed\n      this.log.silly(`state ${id} changed: ${JSON.stringify(state)}`);\n\n      // don't do anything if the state is acked\n      if (state.ack) return;\n\n      // raw.send state?\n      if (this.config.useRawStates && id === `${this.namespace}.raw.send`) {\n        // load and check message data\n        let canMsg: CanMessage;\n        try {\n          canMsg = JSON.parse(state.val as string) as CanMessage;\n        } catch (_e) {\n          this.log.warn(`Invalid JSON in '${this.namespace}.raw.send' state cannot be send!`);\n          return;\n        }\n        if (canMsg && Array.isArray(canMsg.data)) {\n          canMsg.data = Buffer.from(canMsg.data);\n        }\n        if (!canMsg || typeof canMsg.id !== 'number' || !Buffer.isBuffer(canMsg.data)) {\n          this.log.warn(`Invalid message data in '${this.namespace}.raw.send' state cannot be send!`);\n          return;\n        }\n\n        // send the message\n        this.log.debug(`sendig data from raw.send state`);\n        if (this.sendCanMsg(canMsg.id, canMsg.ext || false, canMsg.data, canMsg.rtr || false)) {\n          // set ack flag if the message was send and not already acked\n          if (!state.ack) {\n            await this.setState(id, {\n              ...state,\n              ack: true,\n            });\n          }\n        }\n        return;\n      }\n\n      // get msg und state ID\n      const [ ,, msgId, stateId ] = id.split('.');\n\n      // we only want states of a message objects\n      if (!msgId || !stateId || !msgId.match(MESSAGE_ID_REGEXP_WITH_DLC)) return;\n\n      const msgCfg = this.canId2Message[msgId];\n\n      // we need a message and the message must be configured for sending\n      if (!msgCfg?.send) return;\n\n      switch (stateId) {\n        case 'send':\n          if (state.val !== true) return;\n\n          // use the message action queue to make sure the parsers are done before sending\n          void msgCfg.actionQueue?.enqueue(async () => {\n            // send the current json data\n            if (await this.sendMessageJsonData(msgCfg)) {\n              // set ack flag on the send state if the message was sent\n              await this.setState(`${msgCfg.idWithDlc}.send`, {\n                ...state,\n                ack: true,\n              });\n            }\n          });\n\n          break;\n\n        case 'json':\n          // let the parsers read the data from json to keep the parsers data in sync with the json data\n          await this.processParsers(this.getBufferFromJsonState(state, msgCfg.idWithDlc), msgCfg);\n\n          // send current json data\n          if (msgCfg.autosend) {\n            await this.sendMessageJsonData(msgCfg, state);\n          }\n          break;\n\n        case 'rtr':\n          // nothing to do here\n          break;\n\n        default:\n          // it may be a parser...\n          if (!stateId.match(PARSER_ID_REGEXP)) return;\n\n          // find and run the configured parser\n          for (const parserUuid in msgCfg.parsers) {\n            if (msgCfg.parsers[parserUuid].id !== stateId) continue;\n\n            // check if the parser is initialized\n            const parser = msgCfg.parsers[parserUuid];\n\n            // use the message action queue to make sure the parsers (and a possible followed send) run in correct order\n            await msgCfg.actionQueue?.enqueue(async () => {\n              if (!parser.instance) {\n                return;\n              }\n\n              // load the current json from state\n              const jsonState = await this.getStateAsync(`${msgCfg.idWithDlc}.json`);\n              let data: Buffer | Error | null = this.getBufferFromJsonState(jsonState, msgCfg.idWithDlc);\n              if (data === null) {\n                // state not found or invalid json in state... create default buffer for the parser\n                data = Buffer.alloc(msgCfg.dlc >= 0 ? msgCfg.dlc : 8);\n              }\n\n              // write to data using the parser\n              data = await parser.instance.write(data, state.val);\n\n              // check the write result\n              if (data instanceof Error) {\n                this.log.warn(`Parser writing data for message ID ${msgCfg.idWithDlc} parser ID ${parser.id} failed: ${data}`);\n                return;\n              }\n              if (!(data instanceof Buffer)) {\n                this.log.warn(`Parser writing data for message ID ${msgCfg.idWithDlc} parser ID ${parser.id} failed: Did not return a buffer`);\n                return;\n              }\n\n              // set the new json state with ack=false\n              await this.setState(`${msgCfg.idWithDlc}.json`, JSON.stringify([ ...data ]), false);\n\n              // set ack flag on the parser state\n              await this.setState(`${msgCfg.idWithDlc}.${parser.id}`, {\n                ...state,\n                ack: true,\n              });\n            });\n\n            break;\n          }\n      }\n\n    } else {\n      // The state was deleted\n      this.log.silly(`state ${id} deleted`);\n    }\n  }\n\n  /**\n   * Get a buffer from a `.json` state.\n   * The JSON string of the state will be parsed and checked to be an array.\n   * @param state The state to get the data from.\n   * @param msgId The message ID for logging in case of errors.\n   */\n  private getBufferFromJsonState (state: ioBroker.State | null | undefined, msgId: string): Buffer | null {\n    if (!state) {\n      this.log.warn(`Failed parsing JSON from ${this.namespace}.${msgId}.json: No state found`);\n      return null;\n    }\n\n    let parsedJson: unknown;\n    try {\n      parsedJson = JSON.parse(state.val as string);\n    } catch (err) {\n      this.log.warn(`Failed parsing JSON from ${this.namespace}.${msgId}.json: ${err}`);\n      return null;\n    }\n\n    if (!Array.isArray(parsedJson)) {\n      this.log.warn(`JSON data in ${this.namespace}.${msgId}.json is not an array!`);\n      return null;\n    }\n    if (parsedJson.length > 8) {\n      this.log.warn(`Array length of JSON data in ${this.namespace}.${msgId}.json is greater than 8. Only up to 8 data bytes are supported!`);\n      return null;\n    }\n\n    return Buffer.from(parsedJson);\n  }\n\n  /**\n   * Send the data of a message present in it's json state.\n   * For the json and rtr states of the message the ack flag will be set if the message is sent.\n   * @param msgCfg The `MessageConfig` of the message for which we should send the data.\n   * @param state Optional state to use for sending. If not set, the current state of the object will be read.\n   * @return `true` if the message was sent.\n   */\n  private async sendMessageJsonData (msgCfg: MessageConfig, state?: ioBroker.State | null): Promise<boolean> {\n    // read the state if not given by argument\n    if (!state) {\n      state = await this.getStateAsync(`${msgCfg.idWithDlc}.json`);\n      if (!state) {\n        this.log.warn(`No state found to send for ${this.namespace}.${msgCfg.idWithDlc}.json`);\n        return false;\n      }\n    }\n\n    // parse and check the json data\n    const data = this.getBufferFromJsonState(state, msgCfg.idWithDlc);\n    if (data === null) {\n      return false;\n    }\n\n    // get rtr flag from state\n    const rtrState = this.config.useRtrFlag && await this.getStateAsync(`${msgCfg.idWithDlc}.rtr`);\n    const rtr = (rtrState && !!rtrState.val) ?? false;\n\n    // send the message\n    if (this.sendCanMsg(msgCfg.idNum, msgCfg.ext, data, rtr)) {\n      // set ack flag on json if the message was send and not already acked\n      if (!state.ack) {\n        await this.setState(`${msgCfg.idWithDlc}.json`, {\n          ...state,\n          ack: true,\n        });\n      }\n\n      // set ack on rtr if not already acked\n      if (rtrState && !rtrState.ack) {\n        await this.setState(`${msgCfg.idWithDlc}.rtr`, {\n          ...rtrState,\n          ack: true,\n        });\n      }\n\n      // set raw state if enabled\n      if (this.config.useRawStates) {\n        const canMsg: CanMessage = {\n          id: msgCfg.idNum,\n          ext: msgCfg.ext,\n          data,\n        };\n        if (this.config.useRtrFlag) {\n          canMsg.rtr = rtr;\n        }\n        void this.setState('raw.send', {\n          val: JSON.stringify({\n            ...canMsg,\n            data: [ ...data ],\n          }),\n          ack: true,\n        });\n      }\n\n      return true;\n    } else {\n      this.log.warn(`Sending data message for ${msgCfg.idWithDlc} failed!`);\n      return false;\n    }\n  }\n\n  /**\n   * Setup the object tree for the messages and parsers.\n   */\n  private async setupObjects (): Promise<void> {\n    // loop over configured messages\n    for (const msgUuid in this.config.messages) {\n      const msg = this.config.messages[msgUuid];\n      if (!msg.id.match(MESSAGE_ID_REGEXP)) {\n        this.log.warn(`Message-ID ${msg.id} is invalid. This message will be ignored.`);\n        continue;\n      }\n\n      const msgCfg: MessageConfig = {\n        ...msg,\n        idNum: parseInt(msg.id, 16),\n        idWithDlc: (msg.dlc >= 0) ? `${msg.id}-${msg.dlc}` : msg.id,\n        ext: msg.id.length > 3,\n        uuid: msgUuid,\n      };\n\n      await this.setupMessage(msgUuid, msgCfg);\n    }\n\n    // delete unconfigured message objects\n    if (this.config.deleteUnconfiguredMessages) {\n      const objList = await this.getObjectListAsync({\n        startkey: `${this.namespace}.`,\n        endkey: `${this.namespace}.\\u9999`,\n      });\n\n      // loop over all objects in the namespace of the adapter and check them\n      for (const obj of objList.rows) {\n        // check if obj is a channel (all message objects are created as channel)\n        if (obj.value.type !== 'channel') continue;\n\n        // obj id must have three parts\n        const idParts = obj.id.split('.');\n        if (idParts.length !== 3) continue;\n\n        // obj id part 2 (msgId) must match the message id regexp\n        if (!idParts[2].match(MESSAGE_ID_REGEXP_WITH_DLC)) continue;\n\n        const [ id, dlcStr ] = idParts[2].split('-');\n        const dlc = (dlcStr === undefined) ? -1 : parseInt(dlcStr, 10);\n\n        // is a message with this native.uuid configured with this id?\n        if (this.config.messages?.[obj.value.native.uuid as string]?.id === id\n          && this.config.messages[obj.value.native.uuid as string].dlc === dlc) continue;\n\n        // not configured... delete it recursively\n        this.log.debug(`delete unconfigured message ${obj.id}`);\n        await this.delForeignObjectAsync(obj.id, { recursive: true });\n      }\n    }\n\n    // create or remove raw states\n    if (this.config.useRawStates) {\n      // raw states are enabled\n      await this.extendObject('raw', {\n        type: 'channel',\n        common: {\n          name: 'Raw message data',\n        },\n        native: {},\n      });\n      await this.extendObject('raw.received', {\n        type: 'state',\n        common: {\n          role: 'json',\n          type: 'string',\n          name: 'Last received message',\n          read: true,\n          write: false,\n        },\n        native: {},\n      });\n      await this.extendObject('raw.send', {\n        type: 'state',\n        common: {\n          role: 'json',\n          type: 'string',\n          name: 'Last send message or message to send',\n          read: true,\n          write: true,\n        },\n        native: {},\n      });\n    } else {\n      // raw states are disabled... delete them if exists\n      const chan = await this.getObjectAsync('raw');\n      if (chan) {\n        this.log.debug(`delete raw objects/states`);\n        await this.delObjectAsync('raw', { recursive: true });\n      }\n    }\n  }\n\n  /**\n   * Translate a configured data type to the corresponding ioBroker common type.\n   * @param dataType Data type from the config.\n   * @return The ioBroker common type.\n   */\n  private getCommonTypeFromParser (parser: ioBroker.AdapterConfigMessageParser, msgIdWithDlc: string): ioBroker.CommonType {\n    // custom data type for custom parsers\n    if (parser.dataType === 'custom') {\n      if (parser.customDataType && [ 'string', 'number', 'boolean', 'mixed' ].includes(parser.customDataType)) {\n        return parser.customDataType;\n      }\n      this.log.warn(`Custom parser ${parser.id} of message ${msgIdWithDlc} has no data type set. Please update your configuration.`);\n    }\n\n    // generic data types\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch (parser.dataType) {\n      case 'int8':\n      case 'uint8':\n      case 'int16_be':\n      case 'uint16_be':\n      case 'int16_le':\n      case 'uint16_le':\n      case 'int32_be':\n      case 'uint32_be':\n      case 'int32_le':\n      case 'uint32_le':\n      case 'float32_be':\n      case 'float32_le':\n      case 'double64_be':\n      case 'double64_le':\n        return 'number';\n      case 'boolean':\n        return 'boolean';\n      case 'string':\n        return 'string';\n      default: // e.g. for custom\n        return 'mixed';\n    }\n  }\n\n  /**\n   * Handler for received CAN messages.\n   * @param msg The received CAN message.\n   */\n  @boundMethod\n  private async handleCanMsg (msg: CanMessage): Promise<void> {\n    // TODO: maybe need to check the numeric ID against a Set of known IDs for\n    //       a better performance on systems with very high message load?\n\n    const msgIdHex = getHexId(msg.id, !!msg.ext);\n    let handled = false;\n\n    // save to raw state if enabled\n    if (this.config.useRawStates) {\n      void this.setState('raw.received', {\n        val: JSON.stringify({\n          ...msg,\n          data: [ ...msg.data ],\n        }),\n        ack: true,\n      });\n    }\n\n    if (this.canId2Message[msgIdHex]) {\n      // it's a known message without DLC\n      await this.processReceivedCanMsg(msg, this.canId2Message[msgIdHex]);\n      handled = true;\n    }\n    if (this.canId2Message[`${msgIdHex}-${msg.data.length}`]) {\n      // it's a known message with defined DLC\n      await this.processReceivedCanMsg(msg, this.canId2Message[`${msgIdHex}-${msg.data.length}`]);\n      handled = true;\n    }\n\n    // just end here if the message was handled by at least one config\n    if (handled) {\n      return;\n    }\n\n    if (this.config.autoAddSeenMessages) {\n      // it's not known but we should add it\n      this.log.debug(`auto adding new message ${msg.id}`);\n      const msgCfg: MessageConfig = {\n        id: msgIdHex,\n        idNum: msg.id,\n        idWithDlc: msgIdHex,\n        ext: msgIdHex.length > 3,\n        uuid: null,\n        name: `CAN-Message 0x${msgIdHex}`,\n        dlc: -1,\n        autosend: false,\n        send: false,\n        receive: true,\n        parsers: {},\n      };\n      await this.setupMessage(null, msgCfg);\n\n      void this.setState(`${msgCfg.id}.json`, JSON.stringify([ ...msg.data ]), true);\n      if (this.config.useRtrFlag) {\n        void this.setState(`${msgCfg.id}.rtr`, !!msg.rtr, true);\n      }\n    } else {\n      // known message... just ignore\n      this.log.debug(`ignoring message ${msg.id}`);\n    }\n  }\n\n  /**\n   * Send a CAN message with the given properties.\n   * @param id The numeric ID of the CAN message.\n   * @param ext `true` if the message should be send in extended frame format.\n   * @param data The data of the message. 0 to 8 bytes buffer.\n   * @param rtr Remote transmission request flag.\n   */\n  private sendCanMsg (id: number, ext: boolean, data: Buffer, rtr: boolean): boolean {\n    if (!this.canInterface?.isReady()) {\n      this.log.warn(`Could not send data because CAN interface is not ready.`);\n      return false;\n    }\n\n    return this.canInterface.send(id, ext, data, rtr);\n  }\n\n  /**\n   * Process a received CAN message using the given message config.\n   * @param msg The received CAN message.\n   * @param msgCfg The config for the Message.\n   */\n  private async processReceivedCanMsg (msg: CanMessage, msgCfg: MessageConfig): Promise<void> {\n    // do nothing if the message isn't configured for receiving\n    if (!msgCfg.receive) return;\n\n    // set raw states\n    await this.setState(`${msgCfg.idWithDlc}.json`, JSON.stringify([ ...msg.data ]), true);\n    if (this.config.useRtrFlag) {\n      void this.setState(`${msgCfg.idWithDlc}.rtr`, !!msg.rtr, true);\n    }\n\n    // run the configured parsers\n    void this.processParsers(msg.data, msgCfg);\n  }\n\n  /**\n   * Process all parsers configured for a message to read the values from a buffer.\n   * @param buf The buffer containing the data to read from.\n   * @param msgCfg The message config to use.\n   */\n  private async processParsers (buf: Buffer | null, msgCfg: MessageConfig): Promise<void> {\n    if (!buf) return;\n\n    for (const parserUuid in msgCfg.parsers) {\n      // check if the parser is initialized\n      const parser = msgCfg.parsers[parserUuid];\n      if (parser.instance) {\n        const readResult = await parser.instance.read(buf);\n        // check if the parser has read a value (null indicates an error)\n        if (readResult instanceof Error) {\n          this.log.warn(`Parser ${parser.id} for ${msgCfg.idWithDlc} failed reading from received data: ${readResult}`);\n          continue;\n        }\n        if (readResult === undefined) {\n          this.log.debug(`read parser ${parser.id} for ${msgCfg.idWithDlc} returned undefined`);\n          continue;\n        }\n\n        void this.setState(`${msgCfg.idWithDlc}.${parser.id}`, readResult, true);\n      }\n    }\n  }\n\n  /**\n   * Setup a message for use in this adapter.\n   * This will create/update all needed/configured objects for a message.\n   * This will also initialize the parsers if configured.\n   * @param msgUuid UUID of the message or `null` if it is an unconfigured message.\n   * @param msgCfg The message config containing the information about the message.\n   */\n  private async setupMessage (msgUuid: string | null, msgCfg: MessageConfig): Promise<void> {\n    this.log.debug(`create/update message id: ${msgCfg.idWithDlc}, uuid: ${msgUuid}`);\n\n    // check if this message is already set up\n    if (this.canId2Message[msgCfg.idWithDlc]) {\n      this.log.warn(`Cannot setup message with ID ${msgCfg.idWithDlc} because it's already set up! Maybe this message is configured twice?`);\n      return;\n    }\n\n    // create/update channel object for the message\n    await this.extendObject(msgCfg.idWithDlc, {\n      type: 'channel',\n      common: {\n        name: msgCfg.name || `CAN-Message 0x${msgCfg.id}${msgCfg.dlc >= 0 ? ` DLC ${msgCfg.dlc}` : ''}`,\n      },\n      native: {\n        uuid: msgUuid,\n      },\n    });\n\n    // create/update \"raw\" data state\n    await this.extendObject(`${msgCfg.idWithDlc}.json`, {\n      type: 'state',\n      common: {\n        name: `JSON data`,\n        role: 'json',\n        type: 'string',\n        read: true,\n        write: msgCfg.send, // allow write only if the message is configured for sending\n      },\n      native: {},\n    });\n\n    // create/update or delete \"rtr\" state\n    if (this.config.useRtrFlag) {\n      await this.extendObject(`${msgCfg.idWithDlc}.rtr`, {\n        type: 'state',\n        common: {\n          name: `Remote Transmission Request`,\n          role: 'indicator',\n          type: 'boolean',\n          read: true,\n          write: msgCfg.send, // allow write only if the message is configured for sending\n        },\n        native: {},\n      });\n    } else {\n      const obj = await this.getObjectAsync(`${msgCfg.idWithDlc}.rtr`);\n      if (obj) {\n        await this.delObjectAsync(`${msgCfg.idWithDlc}.rtr`);\n      }\n    }\n\n    // create/update or delete \"send\" state depending on \"send\" option\n    if (msgCfg.send) {\n      await this.extendObject(`${msgCfg.idWithDlc}.send`, {\n        type: 'state',\n        common: {\n          name: msgCfg.autosend ? 'Manually send current data' : 'Send current data',\n          role: 'button',\n          type: 'boolean',\n          read: false,\n          write: true,\n        },\n        native: {},\n      });\n    } else {\n      const obj = await this.getObjectAsync(`${msgCfg.idWithDlc}.send`);\n      if (obj) {\n        await this.delObjectAsync(`${msgCfg.idWithDlc}.send`);\n      }\n    }\n\n    // setup parser objects\n    const parserIdsSetUp = new Set<string>();\n    for (const parserUuid in msgCfg.parsers) {\n      const parser = msgCfg.parsers[parserUuid];\n      if (PARSER_ID_RESERVED.includes(parser.id)) {\n        this.log.warn(`Parser ID ${parser.id} of message ID ${msgCfg.idWithDlc} is reserved and not allowed. This parser will be ignored.`);\n        continue;\n      }\n      if (!parser.id.match(PARSER_ID_REGEXP)) {\n        this.log.warn(`Parser ID ${parser.id} of message ID ${msgCfg.idWithDlc} is invalid. This parser will be ignored.`);\n        continue;\n      }\n      // check if this parser is already set up\n      if (parserIdsSetUp.has(parser.id)) {\n        this.log.warn(`Cannot setup parser with ID ${parser.id} of message with ID ${msgCfg.idWithDlc} because it's already set up! Maybe this parser is configured twice for this message?`);\n        continue;\n      }\n      parserIdsSetUp.add(parser.id);\n      this.log.debug(`create/update parser ${msgCfg.idWithDlc}.${parser.id}`);\n\n      let commonStates: Record<string, string> | undefined;\n      if (parser.commonStates) {\n        if (typeof parser.commonStates === 'string' && parser.commonStates.match(PARSER_COMMON_STATES_REGEXP)) {\n          commonStates = {};\n          const list = parser.commonStates.split(',');\n          for (const l of list) {\n            const [ key, val ] = l.split('=');\n            commonStates[key] = val;\n          }\n        } else {\n          this.log.warn(`Parser ID ${parser.id} of message ID ${msgCfg.idWithDlc} has an invalid list of possible states.`);\n        }\n      }\n\n      // prepare state object\n      const obj: ioBroker.PartialStateObject = {\n        type: 'state',\n        common: {\n          name: parser.name || `Parser ${parser.id}`,\n          type: this.getCommonTypeFromParser(parser, msgCfg.idWithDlc),\n          unit: parser.dataUnit,\n          read: true,\n          write: msgCfg.send, // allow write only if the message is configured for sending\n          states: commonStates,\n        },\n        native: {\n          uuid: parserUuid,\n        },\n      };\n\n      // set parser role if defined in the config... if not defined, the user may set this manually in the state object\n      if (parser.commonRole) {\n        // @ts-expect-error Typescript thinks obj.common may be undefined, but by defining the object above it's always defined\n        obj.common.role = parser.commonRole;\n      }\n\n      // update/set the ioBroker state\n      await this.extendObject(`${msgCfg.idWithDlc}.${parser.id}`, obj);\n    }\n\n    // remove unconfigured parsers\n    const objList = await this.getObjectListAsync({\n      startkey: `${this.namespace}.${msgCfg.idWithDlc}.`,\n      endkey: `${this.namespace}.${msgCfg.idWithDlc}.\\u9999`,\n    });\n    for (const obj of objList.rows) {\n      // check if obj is a state (all parser objects are created as state)\n      if (obj.value.type !== 'state') continue;\n\n      // obj id must have four parts\n      const idParts = obj.id.split('.');\n      if (idParts.length !== 4) continue;\n\n      // obj id part 3 (parserId) must not be in the reserved ids\n      if (PARSER_ID_RESERVED.includes(idParts[3])) continue;\n\n      // is a parser with this native.uuid configured with this id?\n      if (msgCfg.parsers[obj.value.native.uuid as string]?.id === idParts[3]) continue;\n\n      // not configured... delete it with all it's child objects\n      this.log.debug(`delete unconfigured parser ${obj.id}`);\n      await this.delForeignObjectAsync(obj.id);\n    }\n\n    // create action queue\n    msgCfg.actionQueue = new PromiseQueue();\n\n    // save to our canId->msg mapping\n    this.canId2Message[msgCfg.idWithDlc] = msgCfg;\n\n    // setup the parser instances\n    for (const parserUuid in msgCfg.parsers) {\n      for (const Parser of knownParsers) {\n        if (Parser.canHandle(msgCfg.parsers[parserUuid].dataType)) {\n          msgCfg.parsers[parserUuid].instance = new Parser(this, msgCfg.parsers[parserUuid]);\n          break;\n        }\n      }\n\n      // check if an instance is created\n      if (!msgCfg.parsers[parserUuid].instance) {\n        this.log.warn(`No matching parser found for message ID ${msgCfg.idWithDlc} parser ID ${msgCfg.parsers[parserUuid].id} data type ${msgCfg.parsers[parserUuid].dataType}`);\n        continue;\n      }\n\n      // set a defined state value in a certain interval if configured\n      if (typeof msgCfg.parsers[parserUuid].autoSetInterval === 'number') {\n        let val = msgCfg.parsers[parserUuid].autoSetValue;\n        // use defaults if autoSetValue is undefined\n        if (val === undefined) {\n          // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n          switch (msgCfg.parsers[parserUuid].dataType) {\n            case 'boolean':\n              val = false;\n              break;\n            case 'string':\n              val = '';\n              break;\n            case 'custom':\n              // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n              switch (msgCfg.parsers[parserUuid].customDataType) {\n                case 'boolean':\n                  val = false;\n                  break;\n                case 'string':\n                  val = '';\n                  break;\n                case 'number':\n                  val = 0;\n                  break;\n                // case 'mixed': - mixed can be undefined\n              }\n              break;\n            default: // any number\n              val = 0;\n          }\n        }\n        this.log.debug(`setup interval for automatic value set for ${msgCfg.idWithDlc}.${msgCfg.parsers[parserUuid].id} to ${val} every ${msgCfg.parsers[parserUuid].autoSetInterval}ms`);\n        this.intervals.add( // add the interval to the set of running intervals to clear it on adapter unload\n          setInterval(async () => {\n            // set the state\n            await this.setState(`${msgCfg.idWithDlc}.${msgCfg.parsers[parserUuid].id}`, val as ioBroker.StateValue);\n\n            // trigger send if enabled and autosend is disables\n            if (msgCfg.parsers[parserUuid].autoSetTriggerSend && !msgCfg.autosend) {\n              await this.setState(`${msgCfg.idWithDlc}.send`, true, false);\n            }\n          }, msgCfg.parsers[parserUuid].autoSetInterval),\n        );\n      }\n    }\n  }\n}\n\nif (require.main !== module) {\n  // Export the constructor in compact mode\n  module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new CanBusAdapter(options);\n} else {\n  // otherwise start the instance directly\n  (() => new CanBusAdapter())();\n}\n"],
  "mappings": "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",
  "names": []
}
