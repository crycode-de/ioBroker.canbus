{
  "version": 3,
  "sources": ["../src/can-interface-waveshare-can2eth.ts"],
  "sourcesContent": ["/*\n * CAN interface for Waveshare 2-Ch CAN to Ethernet adapter\n * https://www.waveshare.com/wiki/2-CH-CAN-TO-ETH\n *\n * Communication is done via a TCP socket connection to the adapter.\n * The adapter sends and receives raw CAN frames in a fixed 13-byte format.\n *\n * Frame (always 13 bytes):\n *  Byte 0   : Frame information byte\n *             Bit7 (0x80): 1 = Extended frame (29-bit ID), 0 = Standard frame (11-bit ID)\n *             Bit6 (0x40): 1 = RTR (Remote Transmission Request), 0 = Data frame\n *             Bit5..4     : Reserved (should be 0)\n *             Bit3..0     : DLC (Data Length Code 0..8)\n *  Byte 1-4 : CAN ID (big endian). For standard frames only the lower 11 bits are used,\n *             for extended frames the lower 29 bits. Example extended: ID 0x12345678 => 12 34 56 78\n *  Byte 5-12: Data bytes (0-8 valid according to DLC). Remaining bytes padded with 0x00.\n *\n * Notes:\n *  - For RTR frames (Bit6=1) no payload bytes are transmitted; the DLC indicates the requested length.\n */\nimport net from 'node:net';\nimport { boundMethod } from 'autobind-decorator';\nimport type { CanMessage } from 'socketcan';\n\nimport type { CanBusAdapter } from './main';\nimport { CanInterface } from './can-interface';\n\n/**\n * Interface to the CAN bus using Waveshare CAN to Ethernet Server.\n */\nexport class CanInterfaceWaveshareCan2eth extends CanInterface {\n  /** Fixed frame size defined by the protocol */\n  private static readonly FRAME_SIZE = 13;\n\n  /**\n   * The TCP socket to the CAN to Ethernet adapter.\n   */\n  private socket: net.Socket | null = null;\n  /**\n   * Number of performed reconnect attempts (resets to 0 after a successful connection).\n   */\n  private reconnectAttempts = 0;\n  /**\n   * Timer used for a planned reconnect attempt.\n   */\n  private reconnectTimer: ioBroker.Timeout | null = null;\n  /**\n   * Flag set when stop() was called intentionally to prevent automatic reconnects.\n   */\n  private intentionalDisconnect = false;\n  /**\n   * Receive buffer for incoming (possibly fragmented or coalesced) TCP data.\n   */\n  private receiveBuffer: Buffer = Buffer.alloc(0);\n\n  constructor (adapter: CanBusAdapter) {\n    super(adapter);\n  }\n\n  public async start (): Promise<boolean> {\n    this.intentionalDisconnect = false;\n    return await this.connect();\n  }\n\n  public async stop (): Promise<void> {\n    this.intentionalDisconnect = true;\n    // cancel a scheduled reconnect\n    if (this.reconnectTimer !== null) {\n      this.adapter.clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n    await this.disconnect();\n  }\n\n  public isReady (): boolean {\n    return this.started && this.socket !== null && !this.socket.destroyed;\n  }\n\n  public send (id: number, ext: boolean, data: Buffer, rtr: boolean = false): boolean {\n    // Basic connection checks\n    if (!this.socket || this.socket.destroyed || !this.started) {\n      this.adapter.log.warn('Cannot send CAN frame: socket not connected');\n      return false;\n    }\n\n    // ID validation\n    if (ext) {\n      if (id < 0 || id > 0x1FFFFFFF) {\n        this.adapter.log.error(`Extended CAN ID out of range: 0x${id.toString(16)}`);\n        return false;\n      }\n    } else {\n      if (id < 0 || id > 0x7FF) {\n        this.adapter.log.error(`Standard CAN ID out of range: 0x${id.toString(16)}`);\n        return false;\n      }\n    }\n\n    // Data length / DLC\n    let dlc = data.length;\n    if (dlc > 8) {\n      this.adapter.log.warn(`Truncating data from ${dlc} to 8 bytes`);\n      dlc = 8;\n    }\n    if (dlc < 0) dlc = 0; // defensive\n\n    // Build frame buffer (13 bytes fixed)\n    const frame = Buffer.alloc(CanInterfaceWaveshareCan2eth.FRAME_SIZE, 0x00);\n    // Frame info byte\n    frame[0] = (ext ? 0x80 : 0) | (rtr ? 0x40 : 0) | dlc;\n    // Write ID (big endian). Only lower bits are valid; higher bits zeroed by mask.\n    const maskedId = ext ? (id & 0x1FFFFFFF) : (id & 0x7FF);\n    frame.writeUInt32BE(maskedId, 1);\n    // Data (only if not RTR). Even if RTR had data buffer, we do not send payload bytes per protocol.\n    if (!rtr && dlc > 0) {\n      data.subarray(0, dlc).copy(frame, 5);\n    }\n\n    this.adapter.log.silly(`TX raw frame: ${frame.toString('hex')}`);\n    this.adapter.log.debug(`Sending CAN frame id=0x${id.toString(16)}${ext ? ' (ext)' : ''}${rtr ? ' RTR' : ''} dlc=${dlc} data=${(!rtr && dlc > 0) ? data.subarray(0, dlc).toString('hex') : ''}`);\n\n    try {\n      const ok = this.socket.write(frame);\n      if (!ok) {\n        this.adapter.log.silly('Socket write returned false (backpressure), data buffered internally');\n      }\n      return true; // Considered queued\n    } catch (err) {\n      this.adapter.log.error(`Error sending CAN frame: ${(err as Error).message}`);\n      return false;\n    }\n  }\n\n  /**\n   * Connect to the CAN to Ethernet adapter.\n   * @returns `true` if connected, `false` in case of an error.\n   */\n  private async connect (): Promise<boolean> {\n    const { ip, port } = this.adapter.config;\n\n    // wait until we are connected or an error occurs\n    const connected = await new Promise<boolean>((resolve) => {\n      this.adapter.log.debug(`Connecting to CAN to Ethernet adapter at ${ip}:${port}...`);\n\n      this.socket = new net.Socket();\n\n      this.socket.connect(port, ip);\n\n      const connectErrorHandler = (err: Error): void => {\n        this.adapter.log.error(`Error connecting to CAN to Ethernet adapter at ${ip}:${port}: ${err.message}`);\n        this.socket?.destroy();\n        this.socket = null;\n        resolve(false);\n      };\n\n      this.socket.once('connect', () => {\n        this.adapter.log.debug(`Connected to CAN to Ethernet adapter at ${ip}:${port}`);\n        this.socket?.removeListener('error', connectErrorHandler);\n        resolve(true);\n      });\n\n      this.socket.once('error', connectErrorHandler);\n    });\n\n    // fail if we could not connect\n    if (!connected) {\n      this.scheduleReconnect();\n      return false;\n    }\n\n    // reset reconnect attempts counter on success\n    this.reconnectAttempts = 0;\n\n    // listen for incoming data\n    this.socket!.on('data', this.handleSocketData);\n\n    // handle runtime errors (after initial connection). We only log them \u2013 the 'close' event will trigger the reconnect.\n    this.socket!.on('error', (err) => {\n      this.adapter.log.warn(`Socket error: ${err.message}`);\n    });\n\n    // handle socket closed event (also triggered after 'end')\n    this.socket!.on('close', (hadError) => {\n      if (this.intentionalDisconnect) {\n        this.adapter.log.debug('Socket closed intentionally');\n        return;\n      }\n      this.adapter.log.warn(`Socket closed${hadError ? ' due to a transmission error' : ''}. Will attempt to reconnect.`);\n      this.socket = null;\n\n      // mark interface as not started for now\n      this.started = false;\n      this.emit('stopped');\n\n      this.scheduleReconnect();\n    });\n\n    this.started = true;\n    this.emit('started');\n    this.adapter.log.info('CAN to Ethernet adapter connection established and ready');\n\n    return true;\n  }\n\n  /**\n   * Disconnect from the CAN to Ethernet adapter.\n   */\n  private async disconnect (): Promise<void> {\n    if (this.socket) {\n      this.adapter.log.debug('Disconnecting from CAN to Ethernet adapter...');\n\n      // create a copy of the socket reference and set to null to avoid\n      // sending on a closed socket\n      const socket = this.socket;\n      this.socket = null;\n\n      // wait until the socket is fully closed\n      await new Promise<void>((resolve) => {\n        // set a timeout in case the socket does not close properly\n        const timeout = this.adapter.setTimeout(() => {\n          if (!socket.destroyed) {\n            this.adapter.log.warn('Timeout while disconnecting from CAN to Ethernet adapter');\n            socket.destroy();\n          }\n        }, 5000);\n\n        // resolve when the socket is closed\n        socket.once('close', () => {\n          this.adapter.clearTimeout(timeout);\n          resolve();\n        });\n\n        // in case of an error just destroy the socket\n        socket.once('error', (err) => {\n          this.adapter.log.error(`Error while disconnecting from CAN to Ethernet adapter: ${err.message}`);\n          if (!socket.destroyed) socket.destroy();\n        });\n\n        // end the socket connection\n        socket.end();\n      });\n\n      this.started = false;\n      this.emit('stopped');\n      this.adapter.log.info('Disconnected from CAN to Ethernet adapter');\n    }\n  }\n\n  /**\n   * Handle incoming data from the CAN to Ethernet adapter.\n   * @param received The incoming data buffer.\n   */\n  @boundMethod\n  private handleSocketData (received: Buffer): void {\n    // Append incoming data to buffer (TCP may fragment or coalesce multiple frames)\n    if (received.length === 0) return;\n    this.receiveBuffer = Buffer.concat([ this.receiveBuffer, received ]);\n    this.adapter.log.silly(`RX append (${received.length}B): total=${this.receiveBuffer.length} hex=${received.toString('hex')}`);\n\n    // Process as long as at least one full frame (13 bytes) is available\n    while (this.receiveBuffer.length >= CanInterfaceWaveshareCan2eth.FRAME_SIZE) {\n      const frame = this.receiveBuffer.subarray(0, CanInterfaceWaveshareCan2eth.FRAME_SIZE);\n      this.receiveBuffer = this.receiveBuffer.subarray(CanInterfaceWaveshareCan2eth.FRAME_SIZE);\n\n      const frameInfo = frame[0];\n      const ext = (frameInfo & 0x80) !== 0; // Extended flag\n      const rtr = (frameInfo & 0x40) !== 0; // RTR flag\n      const dlc = frameInfo & 0x0F; // DLC\n\n      if (dlc > 8) {\n        this.adapter.log.warn(`Invalid DLC (${dlc}) in frame info byte 0x${frameInfo.toString(16)} \u2013 discarding frame`);\n        continue; // Skip invalid frame\n      }\n\n      // Extract CAN ID\n      const rawId = frame.readUInt32BE(1);\n      const id = ext ? (rawId & 0x1FFFFFFF) : (rawId & 0x7FF);\n\n      // Extract data bytes (for RTR no payload even if padding exists)\n      const data = rtr ? Buffer.alloc(0) : frame.subarray(5, 5 + dlc);\n\n      const msg: CanMessage = { id, ext, rtr, data };\n      this.adapter.log.debug(`Received CAN frame id=0x${id.toString(16)}${ext ? ' (ext)' : ''}${rtr ? ' RTR' : ''} dlc=${dlc} data=${(!rtr && dlc > 0) ? data.subarray(0, dlc).toString('hex') : ''}`);\n      this.emit('message', msg);\n    }\n  }\n\n  /**\n   * Schedule a reconnect attempt with exponential backoff.\n   * Backoff: 2s, 4s, 8s, ... up to max 60s.\n   */\n  private scheduleReconnect (): void {\n    if (this.intentionalDisconnect) return; // do not reconnect if stop() requested\n    if (this.reconnectTimer) return; // already scheduled\n\n    const delay = Math.min(60000, 2000 * Math.pow(2, this.reconnectAttempts));\n    this.adapter.log.debug(`Scheduling reconnect attempt #${this.reconnectAttempts + 1} in ${delay / 1000}s`);\n\n    const t = this.adapter.setTimeout(async () => {\n      this.reconnectTimer = null; // timer consumed\n      if (this.intentionalDisconnect) return; // double-check\n\n      this.reconnectAttempts++;\n      await this.connect();\n    }, delay);\n    this.reconnectTimer = t ?? null;\n  }\n}\n"],
  "mappings": "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",
  "names": ["net"]
}
