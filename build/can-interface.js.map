{
  "version": 3,
  "sources": ["../src/can-interface.ts"],
  "sourcesContent": ["import * as socketcan from 'socketcan';\nimport { EventEmitter } from 'events';\nimport type { CanBusAdapter } from './main';\n\ninterface CanInterfaceEvents {\n  message: [msg: socketcan.CanMessage];\n  started: [];\n  stopped: [];\n}\n\n/**\n * Interface to the CAN bus using socketcan.\n */\nexport abstract class CanInterface extends EventEmitter<CanInterfaceEvents> {\n  protected adapter: CanBusAdapter;\n  protected started: boolean = false;\n\n  constructor (adapter: CanBusAdapter) {\n    super();\n\n    this.adapter = adapter;\n  }\n\n  /**\n   * Create and start the channel of the CAN interface.\n   * Need to be called before we can send/receive any messages.\n   * @return `true` if the channel is started, `false` in case of an error.\n   */\n  public abstract start (): Promise<boolean>;\n\n  /**\n   * Stop the channel of the CAN interface.\n   * If stopped no more messages will be received but it may be possible to send\n   * messages anyways.\n   */\n  public abstract stop (): Promise<void>;\n\n  /**\n   * Check if the interface is ready to send/receive data.\n   * @return `true` if ready.\n   */\n  public abstract isReady (): boolean;\n\n  /**\n   * Send a can message with the given properties.\n   * @param id The numeric ID of the CAN message.\n   * @param ext `true` if the message should be send in extended frame format.\n   * @param data The data of the message. 0 to 8 bytes buffer.\n   * @param rtr Remote transmission request flag.\n   * @return `true` if the message is sent.\n   */\n  public abstract send (id: number, ext: boolean, data: Buffer, rtr?: boolean): boolean;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,oBAA6B;AAYtB,MAAe,qBAAqB,2BAAiC;AAAA,EAI1E,YAAa,SAAwB;AACnC,UAAM;AAHR,SAAU,UAAmB;AAK3B,SAAK,UAAU;AAAA,EACjB;AA+BF;",
  "names": []
}
